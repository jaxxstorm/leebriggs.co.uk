---
title: "DSLs are a waste of time"
layout: post
category: blog
tags:
- devops
- infrastructure-as-code
---

If you've read this blog before, or are unfortunate enough to have an actual personal relationship with me, you'll know that I have strong opinions and can be, shall we say, _passionate_ about them. For posts on this blog, I try to share those opinions and avoid directly addressing the people who hold the opposing view.

However there's a schism happening in the infrastructure as code world at the moment with the announcement that HashiCorp is changing the software license that it uses for its products. As a result, and for reasons that have been covered in great depth by people far more qualified than I am, this has resulted in a set of vocal competitors to Terraform Cloud and Terraform Enterprise to "fork" (and that's a loose interpretation of the word because because all we have at the time of writing is a markdown file and some gifs) called OpenTF.

As we watch these two competing factions live out [Friedrich Glasl's model of conflict escalation](https://en.wikipedia.org/wiki/Friedrich_Glasl%27s_model_of_conflict_escalation) in public, I have found myself asking a question that has always lingered in the back of mind while working in my day job at [Pulumi](https://pulumi.com)

**Why the fuck does everyone love this domain specific language so much?**

## Hold your horses, Terraform isn't just a DSL!

Your first reaction will undoubtedly be "well, it's not the DSL we love, it's Terraform! It's made me more productive and solves real world problems!"

I understand the impact Terraform has had on Infrastructure as Code and DevOps in general. I'm lucky enough to consider two of the [top 10 contributors of all time to Terraform](https://github.com/hashicorp/terraform/graphs/contributors) close personal friends and we generally hold similar perspectives on things (although, one of them has appaling taste in beer, I know you're reading this). 

I used Terraform from the very first version, back when every time you ran `terraform apply` you sort of closed your eyes and hoped you didn't break everything. I watched in wonder as Terraform introduced modules, started adding hundreds of providers to support basically every cloud provider you could think of. As our industry started to migrate to "cloud first" or "cloud native" I migrated by world view from one of "configuration management" to "infrastructure as code" and became a subject matter expert.

All of this is to say, I _get it_. I understand why people want to use Terraform, and I can sort of understand why people are so upset about the license change and want to support the forking of the product so it stays "open source".

The problem here is that while you can say "Terraform is more than a DSL" - if you ever have a conversation with someone who's a true dyed in the wool Terraform zealot and start to try and understand where they're coming from, you begin to realise they don't love Terraform, they love this weird half language because they're an expert in it, and frankly I really don't understand it.

## A path to nowhere

I've used a DSL before, you see. Even before Terraform. I spent a whole 7 or 8 years writing thousands of lines of DSL.

Puppet has its own Ruby based DSL it now calls [the Puppet language](https://www.puppet.com/docs/puppet/7/puppet_language.html) and before we had Terraform, we had Puppet. When all of the problems in the infrastructure space existed at the operating system instead of the API layer, Puppet was _everywhere_ and I _loved_ the language because it meant I didn't have to be a "software developer". I didn't want to write PHP or Python, I wanted to manage infrastructure, and Puppet's DSL let me do that.

The problem with this mentality was that when the industry inevitably changed around me, I was left with an expertise and knowledge of a language that was now, **effectively useless**. I haven't written a single line of Puppet language in a long time, and I don't miss it at all. I don't miss the syntax, parsing the docs and trying to figure out how these built in functions actually worked and mapping those ideas to problem sets.

I made the same mistake again though with Terraform, and what you start to realise is that the people who are so passionate about Terraform are the people who have invested so much time and energy into learning the language and becoming experts in it. They don't want to have to learn something new, they don't want to have to start over, and they don't want to have to admit that they've spent years of their life learning something that is, ultimately, a dead end.

## The arguments for DSLs

Now, holding this position privately has meant I've had these discussion before, so I have an idea what the people reading this are telling themselves. Let's look at a few of these arguments and try and stay reasonably objective.

### DSLs are less complex

This one is always going to have some degree of subjectivity at its core, but what's worth remembering here is that the complexity is not necessarily in the language itself, but in the problem space that the language is trying to solve.

Terraform's language has evolved dramatically over time to try and keep up with the needs of its users. The problem of course is that cloud infrastructure continues to be complex and difficult to manage, and so the language has to evolve to keep up with that complexity.

If you do a quick search of a sufficiently complex Terraform module, you'll see _all kinds of craziness_. I just picked a random module from the Terraform registry and looked at the `main.tf` and found this:

```hcl
resource "aws_route_table_association" "redshift" {
  count = local.create_redshift_subnets && !var.enable_public_redshift ? local.len_redshift_subnets : 0

  subnet_id = element(aws_subnet.redshift[*].id, count.index)
  route_table_id = element(
    coalescelist(aws_route_table.redshift[*].id, aws_route_table.private[*].id),
    var.single_nat_gateway || var.create_redshift_subnet_route_table ? 0 : count.index,
  )
}

resource "aws_route_table_association" "redshift_public" {
  count = local.create_redshift_subnets && var.enable_public_redshift ? local.len_redshift_subnets : 0

  subnet_id = element(aws_subnet.redshift[*].id, count.index)
  route_table_id = element(
    coalescelist(aws_route_table.redshift[*].id, aws_route_table.public[*].id),
    var.single_nat_gateway || var.create_redshift_subnet_route_table ? 0 : count.index,
  )
}
```

Now, don't get me wrong, I know what this is doing, and I also understand why it has to be implemented this way, but if you're not an expert in this space, you probably have a whole bunch of reasonable questions:

- Why are we using `count` here?
- What is `coalescelist`?
- What is `element`?
- What is `local`?

And that's just the first few lines. I'm not trying to pick on this module, I'm just trying to demonstrate that even in a language that is supposed to be "simple" and "easy to understand" you can still end up with code that is complex and difficult to understand.

Terraform's DSL allows you to use abstractions (modules), nest resources inside those abstractions and then create varying levels of indirection when trying to instantiate resources. These things are all necessary when trying to truly create an ecosystem that allows reusability and sharing, but of course that brings with it complexity.

My personal opinion here is that when people say "it's less complex" - what they actually mean is "I understand it". Which is totally fine, and a reasonable position to be in, but it's not the same thing. If you're a "devops engineer" or "platform engineer" (or whatever the job title is called this week) and you look at the application code you're supporting which is all scarily object orientated can't want to figure out where this object comes from - put yourself in the position of an application developer trying to look at YOUR Terraform code and think about _their_ perspective. It's just as difficult, and it was your job to _learn_ Terraform's DSL, the application developer has a full time job AND now you're expecting them to learn this weird DSL too?

### DSL's are fit for purpose

The position here is that Terraform's DSL is perfectly crafted to prevent you implementing overly complex code and "blowing your foot off". A domain specific language has the clue in its name, it's "domain specific" and the domain itself is provisioning infrastructure. It's lack of features and simplicty which make it a DSL and not a programming language is what makes it so good.

Putting aside the idea that what these folks are really arguing id that the lack of features _is it itself a feature_ what you have to remember here is that DSL being domain specific means that if the domain you're learning changes, what you've learned is completely irrelevant. 

If you look at the general path infrastructure as code tools are going, with the implementation of CDKs for AWS and now Terraform as well, and path towards a programming language authoring model being the is well defined. Programming languages are reusable in other use case and now have the ability and flexibility to effortless describe the complexity of cloud infrastructure.














